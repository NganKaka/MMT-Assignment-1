ASSIGNMENT 1
Goal: application of client-server, P2P, network programming
Content:
Task 1: Client-server, login, cookie
Task 2: P2P, chat application
TCP network programming
Introduction
1.1 Overview
Implement a HTTP server application equipped with a webapp chat application
Server application has multiple processes with a proxy server process (ng điều phối, nhận yc từ client và chuyển vào dịch vụ backend) & multiple backend server process.
WeApRousp framework: provide environment for P2P application


1.2 Source code
Thư mục gốc: daemon
Là bộ não của server, chứa toàn bộ logic để xử lý request, tạo response
response.py, request.py
backend.py: xử lý logic server
httpadapter.py: lớp trung gian, dịch các dữ liệu thô từ kết nối socket thành các đối tượng request/response HTTP mà server hiểu được 
weaprous.py: chứa source code của framework WeApRous
dictionary.py: module chứa CTDL dùng được
Thư mục: www & static
www: chứa các trang web tĩnh (index.html, …)
static: images, css, js
Thư mục khác:
apps: nơi đặt các webapp tùy chỉnh
cert: các chứng chỉ, dùng để kết nối HTTPs
db
config: chứa file cấu hình
Các file thực thi: (file python mà chạy trực tiếp trên terminal)
start_proxy.py: khởi chạy Proxy process
start_backend.py: khởi chạy BE process
start_sampleapp.py: khởi chạy 1 tiến trình Webapp (WeApRous) - ứng dụng chat
1.3 Server process
Proxy:
Intermediary between clients & backend/webapp
Receive requests from clients => forward to appropriate backend
Adv:
Managing traffic
Load balancing: nhiều backend server => proxy phân phối yc hợp lý
Scalability, resilience: client ko cần biết cấu trúc backend bên trong
Backend:
Core services, handle requests
Backend pool includes multiple backend instances
WebApp - WeApRous:
WeApRous (viết tắt của WebAppRoutes): là 1 loại backend chuyên biệt, cung cấp các dịch vụ cho client:
Xử lý các tác vụ liên quan đến UI như: Cung cấp giao diện cho client (HTML, CSS, ảnh)
Tương tác với client thông qua Rest API
Hoạt động giống như backend thông thường, cũng nhận yc qua Proxy. Tuy nhiên có thể chạy mà ko cần Proxy
1.4 How to create a server process?
Tạo Proxy process:
# From daemon/proxy.py
def create_proxy(ip, port, routes):
run_proxy(ip, port, routes) 
Tạo backend process:
# From daemon/backend.py
def create_backend(ip, port, routes={}):
run_backend(ip, port, routes) 
Tạo WebApp:
# From ./start_sampleapp.py 
app = WeApRous() 
@app.route(’/op1’, methods=[’POST’])
def op1(headers="guest", body="anonymous"): …
@app.route(’/op2’, methods=[’PUT’]) 
def op2(headers="guest", body="anonymous"): ... 


Nếu có 1 HTTP request sử dụng POST đến /op1, hãy thực thi hàm op1
1.5 How to run the server?
Tệp cấu hình của Proxy (config/proxy.conf):
Là bộ quy tắc/bản đồ chỉ đường cho Proxy Server. Khi Proxy Server nhận được 1 client request, nó sẽ nhìn vào tệp này để biết làm gì tiếp theo
Mỗi khối cấu hình bắt đầu bằng host “...” {...}
host “...”: hostname/ IP address and Port (optional)
{...}: là các chỉ thị (directives) - lệnh cho proxy biết cách xử lý
Important directives:
proxy_pass [URL] : chuyển tiếp y/c đến URL này
VD: Bất kỳ y/c nào đến app1.local thì hãy gửi nó đến backend server đang chạy trên http://192.168.56.103:9001
dist_policy [strategy] : chỉ thị này được dùng khi có nhiều proxy_pass trong cùng 1 khối {...} (strategy: least-conn, random)
VD: Trong khối app2.local, có 2 backend server. dist_policy round-robin: Proxy sẽ phân phối luân phiên - BE1 => BE2 => BE1 …. Còn proxy_set_header [HeaderName] [Value] cho phép sửa đổi hoặc thêm header vào HTTP request trước khi chuyển tới backend

Mã nguồn chạy Server:
Dùng argparse để định IP address và port linh hoạt
Ex: python start_proxy.py --server-ip 192.168.1.50 --server-port 8080
Nếu ko chỉ định: mặc định IP=0.0.0.0 và port = PROXY_PORT




Chạy proxy (start_proxy.py):
routes = parse_virtual_hosts("config/proxy.conf"): đọc tệp cấu hình proxy.conf và chuyển thành CTDL mà Python hiểu
create_proxy(ip, port, routes): chạy Proxy Server
Chạy backend (start_backend.py)
create_backend(ip, port)
Chạy WebApp:
app.prepare_address(ip, port): cấu hình IP và port cho ứng dụng WeApRous
app.run(): chạy


Implementation
2.1 HTTP server with cookie session:
Goal: authenticate users via login form and maintain their login state using HTTp cookies
Task 1A: implement authentication handling:
Khi nào? Server nhận y/c POST đến /login
Làm gì? Server kiểm tra thông tin đăng nhập được gửi lên:
Nếu valid: (username=admin, password=password) server trả về trang index (được vệ) kèm 1 header Set-Cookie: auth=true
Invalid: server trả về 401 Unauthorized


Task 1B: Implement cookie-based access control
Khi nào? Khi client gửi y/c GET đến đường dẫn /
Làm gì? Server kiểm tra xem trong y/c của user có vé auth=true không
Nếu có: Server phục vụ trang index
Ko có hoặc vé ko đúng: 401 unauthorized



Dùng Tab ẩn danh: vì browser thường lưu bộ đệm (cache) làm cho thấy kq cũ thay vì mới nhất từ server
Xử lý vấn đề:
Header parsing: đọc hiểu các headers trong HTTP request để tìm cookie user gửi lên. Đồng thời phải biết cách tạo header Set-Cookie trong response
Session Management: logic phát vé và kiểm tra vé
Concurrency: Server phục vụ nhiều users cùng lúc bằng cách dùng threading
Error handling: xử lý lỗi để server ko sập

2.2 Implement hybrid chat application
Description: Hybrid network application - client-server (dùng để lấy IP) + P2P (chat trực tiếp)
Công cụ sử dụng:
WeApRous: framework (start_sampleapp.py) giúp tạo API
RESTful: phong cách thiết kế API (GET, POST, PUT)
Các bước xây dựng:
Khởi tạo (Client-server)
Giai đoạn “lấy danh bạ”, tất cả peer nói chuyện với server trung tâm (Tracker) để biết ai đang online
Peer registration: khi mở ứng dụng chat, bạn gửi IP+port cho Tracker Server (trở thành 1 peer)
Tracker Update: tracker server nhận thtin của bạn và ghi vào 1 cuốn sổ (danh sách) tất cả ng đang hoạt động
Peer discovery: Bạn hỏi tracker server “Ai đang hoạt động?”
Connection setup: Tracker server gửi cuốn sổ cho bạn và bạn dùng IP+port kết nối P2P trực tiếp đến P2P khác
Chat (P2P):
Direct peer communication: bạn gửi tin nhắn trực tiếp đến IP/port của bạn bè mà ko cần tracker server
Broadcast connection: khi gửi 1 tin nhắn, phải gửi nó đến tất cả peer khác mà bạn đang kết nối
Channel management:
Channel listing: users can view channels they joined
Message display: each channel has a scrollable message window
Message submission: UI must support text input & submission
No edit/delete (tin nhắn đã gửi là vĩnh viễn, ko được sửa/xóa
Phải có thông báo khi có tin nhắn mới
Access control (Optional): Channels may define custom access policies
Tasks:
Viết code client (peer) + server (Tracker Server) process programming
Protocol design: phải tự định nghĩa message format (VD: khi gửi tin nhắn P2P, dữ liệu có dạng {“user”:”Alice”, “message”:”abc”}
Api cần xây dựng:

Concurrency: Tracker server phải xử lý nhiều peer đăng ký cùng lúc, 1 peer phải vừa nhận tin nhắn, vừa gửi tin nhắn được
Error handling
3. Submissions:
3.1 Source code:
Tuân theo coding style:
PEP 8– Style Guide for Python Code- https://peps.python.org/pep-0008 
PEP 257– Docstring Conventions- https://peps.python.org/pep-0257/


3.2 Requirements:
Application & protocol design: thiết kế dựa trên TCP/IP (ko dùng framework có sẵn)
Cookie session (task1)
Chat application (task 2)

 After you finish the assignment, move your report to source code directory and compress the entire directory into a single file named assignment STUDENTID.zip and submit to LMS
