<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Messenger Chat Hybrid</title>
    <style>
        /* ==== N·ªòI DUNG STYLE.CSS ==== */
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: Arial, sans-serif; }

        body { background-color: #f0f2f5; height: 100vh; display: flex; align-items: center; justify-content: center; }

        #chat-screen {
            width: 900px; height: 600px; background: white; display: flex;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden;
        }

        /* C·ªôt tr√°i: Danh s√°ch */
        .sidebar { width: 250px; background: #fff; border-right: 1px solid #ddd; display: flex; flex-direction: column; }
        .sidebar-header { padding: 20px; border-bottom: 1px solid #eee; background: #f5f5f5; }
        .online-list-container { flex: 1; overflow-y: auto; }
        #peer-list { list-style: none; }
        .peer-item {
            padding: 15px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: 0.2s;
        }
        .peer-item:hover { background-color: #f0f2f5; }
        .peer-item.active { background-color: #e6f2ff; border-left: 4px solid #0084ff; font-weight: bold; }

        /* C·ªôt ph·∫£i: Chat ch√≠nh */
        .main-chat { flex: 1; display: flex; flex-direction: column; }
        .chat-header { padding: 15px; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center; background: white; }
        .active-status { color: #31a24c; font-size: 12px; margin-left: 10px; }

        /* Khu v·ª±c tin nh·∫Øn */
        .message-area { flex: 1; padding: 20px; overflow-y: auto; background-color: #fff; display: flex; flex-direction: column; gap: 10px; }
        .system-msg { text-align: center; color: #888; font-size: 13px; margin-bottom: 20px; }

        .message { max-width: 70%; padding: 10px 15px; border-radius: 18px; font-size: 14px; line-height: 1.4; position: relative; }
        .msg-sender { font-size: 10px; color: #555; margin-bottom: 4px; }

        /* Tin nh·∫Øn m√¨nh g·ª≠i */
        .message.sent { align-self: flex-end; background-color: #0084ff; color: white; }
        .message.sent .msg-sender { color: #e6e6e6; text-align: right; }

        /* Tin nh·∫Øn ng∆∞·ªùi kh√°c */
        .message.received { align-self: flex-start; background-color: #f0f0f0; color: black; }

        /* Footer nh·∫≠p li·ªáu */
        .chat-footer { padding: 20px; border-top: 1px solid #ddd; display: flex; gap: 10px; }
        #msg-input { flex: 1; padding: 10px; border-radius: 20px; border: 1px solid #ccc; outline: none; }
        .send-btn { padding: 10px 20px; background-color: #0084ff; color: white; border: none; border-radius: 20px; cursor: pointer; font-weight: bold; }
        .send-btn:hover { background-color: #0073e6; }

        /* ==== CSS b·ªï sung trong HTML c≈© ==== */
        .section-title { padding: 10px 15px; font-size: 12px; color: #666; font-weight: bold; background: #eee; text-transform: uppercase; }
        .input-group { padding: 10px; border-bottom: 1px solid #ddd; display: flex; }
        .input-group input { flex: 1; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
        .input-group button { margin-left: 5px; padding: 5px 10px; background: #0084ff; color: white; border: none; border-radius: 3px; cursor: pointer; }

        #channel-list, #peer-list { list-style: none; padding: 0; }
        .item-list { padding: 15px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: 0.2s; }
        .item-list:hover { background-color: #f0f2f5; }
        .item-list.active { background-color: #e6f2ff; border-left: 4px solid #0084ff; font-weight: bold; }

        .channel-icon::before { content: 'üì¢ '; }
        .peer-icon::before { content: 'üë§ '; }
    </style>
</head>
<body>
    <div id="chat-screen">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>WeApRous Chat</h3>
            </div>
            
            <!-- T·∫°o/V√†o K√™nh -->
            <div class="input-group">
                <input type="text" id="new-channel-name" placeholder="Nh·∫≠p t√™n k√™nh...">
                <button onclick="joinChannel()">V√†o</button>
            </div>

            <div class="online-list-container">
                <div class="section-title">K√™nh Chat</div>
                <ul id="channel-list"></ul>

                <div class="section-title">Ng∆∞·ªùi d√πng Online</div>
                <ul id="peer-list"></ul>
            </div>
        </div>

        <div class="main-chat">
            <div class="chat-header">
                <div class="chat-info">
                    <h4 id="current-user-display">ƒêang t·∫£i...</h4>
                    <span class="active-status">‚óè ƒêang ho·∫°t ƒë·ªông</span>
                </div>
            </div>

            <div id="message-window" class="message-area">
                <div class="system-msg">Ch√†o m·ª´ng! H√£y ch·ªçn ng∆∞·ªùi ho·∫∑c k√™nh ƒë·ªÉ chat.</div>
            </div>

            <div class="chat-footer">
                <input type="text" id="msg-input" placeholder="Nh·∫≠p tin nh·∫Øn..." onkeypress="handleEnter(event)">
                <button class="send-btn" onclick="sendMessage()">G·ª≠i</button>
            </div>
        </div>
    </div>

    <script>
        let currentUser = null;
        let currentTarget = null;
        let currentType = null;
        let chatHistory = {}; 
        let unreadCounts = {}; 

        function startChatApp(user) {
            currentUser = user;
            console.log("Logged in as:", currentUser);
            
            loadHistoryFromLocal();
            
            fetchData();
            setInterval(fetchData, 3000);

            fetchMessages();
            setInterval(fetchMessages, 2000);
        }

        async function fetchData() {
            fetchPeerList();
            fetchChannelList();
        }

        // --- X·ª¨ L√ù PEER ---
        async function fetchPeerList() {
            try {
                const response = await fetch('/get-list') 
                if (response.ok) {
                    const data = await response.json();
                    const peers = Array.isArray(data) ? data : (data.peers || []);
                    renderPeerList(peers);
                }
            } catch (e) {}
        }

        function renderPeerList(peers) {
            const listElement = document.getElementById('peer-list');
            listElement.innerHTML = ''; 
            peers.forEach(peer => {
                if(peer.name === currentUser) return;
                const li = document.createElement('li');
                li.className = 'item-list peer-icon';
                
                const count = unreadCounts[peer.name] || 0;
                if (count > 0) { li.classList.add('has-unread'); li.innerText = `${peer.name} (${count})`; }
                else { li.innerText = peer.name; }

                if (currentTarget === peer.name && currentType === 'direct') li.classList.add('active');

                li.onclick = () => switchChat(peer.name, 'direct');
                listElement.appendChild(li);
            });
        }

        // --- X·ª¨ L√ù CHANNEL ---
        async function joinChannel() {
            const name = document.getElementById('new-channel-name').value.trim();
            if (!name) return;

            const peer = {
                name: currentUser,
                ip: localStorage.getItem("peer_ip"),
                port: localStorage.getItem("peer_port")
            };

            try {
                const response = await fetch('/add-list', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        channel: name, 
                        peer: peer                // ‚úÖ ƒê√öNG CHU·∫®N BACKEND
                    })
                });

                const data = await response.json();
                if (data.status === "ok") {
                    document.getElementById('new-channel-name').value = "";
                    fetchChannelList();
                    alert("ƒê√£ tham gia k√™nh: " + name);
                }
            } catch (e) {
                console.error(e);
            }
        }

        async function fetchChannelList() {
            console.log("Fetching channel list for user:", currentUser);

            try {
                const response = await fetch("/get-channels");
                if (!response.ok) return;

                const data = await response.json();
                console.log("RAW CHANNELS:", data);

                const joinedChannels = [];

                for (const chName in data) {
                    const chObj = data[chName];   // m·ªói channel l√† 1 object
                    console.log(`CHECK CHANNEL ${chName}:`, chObj);

                    // ƒë·∫£m b·∫£o c√≥ tr∆∞·ªùng peers v√† l√† list
                    if (!chObj || !Array.isArray(chObj.peers)) {
                        console.warn(`Channel ${chName} invalid peers`, chObj);
                        continue;
                    }

                    const peerList = chObj.peers;
                    console.log("PEER LIST:", peerList);

                    // t√¨m user
                    const isMember = peerList.some(p => p.name === currentUser);

                    if (isMember) {
                        console.log(`‚Üí USER '${currentUser}' belongs to channel '${chName}'`);
                        joinedChannels.push(chName);
                    }
                }

                console.log("JOINED CHANNELS:", joinedChannels);

                renderChannelList(joinedChannels);

            } catch (e) {
                console.error("fetchChannelList error:", e);
            }
        }

        function renderChannelList(channels) {
            const listElement = document.getElementById('channel-list');
            listElement.innerHTML = '';

            channels.forEach(ch => {
                const li = document.createElement('li');
                li.className = 'item-list channel-icon';

                const count = unreadCounts[ch] || 0;
                li.innerText = count > 0 ? `${ch} (${count})` : ch;

                if (currentTarget === ch && currentType === 'channel')
                    li.classList.add('active');

                li.onclick = () => switchChat(ch, 'channel');
                listElement.appendChild(li);
            });
        }


        // --- CHUY·ªÇN ƒê·ªîI ---
        function switchChat(target, type) {
            currentTarget = target;
            currentType = type;
            unreadCounts[target] = 0; // Reset unread
            
            // Update UI
            fetchData(); 
            document.querySelector('.system-msg').innerText = 
                (type === 'channel' ? 'üì¢ ' : 'üë§ ') + target;
            loadChatHistory(target);
        }

        // --- G·ª¨I TIN NH·∫ÆN ---
        async function sendMessage() {
            const input = document.getElementById('msg-input');
            const msg = input.value.trim();
            if (!msg || !currentTarget) return;

            // L∆∞u history
            appendMessageToUI(currentUser, msg, 'sent');
            if (!chatHistory[currentTarget]) chatHistory[currentTarget] = [];
            chatHistory[currentTarget].push({ sender: currentUser, msg: msg });
            saveHistoryToLocal();

            const url = currentType === 'direct' ? '/send-peer' : '/broadcast-peer';
            const body = {
                sender: currentUser,
                msg: msg,
                target: currentType === 'direct' ? currentTarget : undefined,
                channel: currentType === 'channel' ? currentTarget : undefined
            };

            try {
                await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                input.value = '';
            } catch (e) {}
        }

        // --- NH·∫¨N TIN NH·∫ÆN ---
            // async function fetchMessages() {
        //     // Kh√¥ng load g√¨ n·∫øu ch∆∞a ch·ªçn target
        //     if (!currentUser || !currentTarget) return;

        //     let url = "/get-messages";

        //     if (currentType === "channel") {
        //         url += `?channel=${currentTarget}`;
        //     } else {
        //         url += `?peer_id=${currentUser}`;
        //     }

        //     try {
        //         const response = await fetch(url);
        //         if (!response.ok) return;

        //         const data = await response.json();
        //         const msgs = data.messages || data;  // backend tr·∫£ {"messages": [...]} ho·∫∑c [...]

        //         msgWindow = document.getElementById('message-window');

        //         msgs.forEach(m => {
        //             const sender = m.sender;
        //             const text   = m.msg || m.message;

        //             // l∆∞u history
        //             if (!chatHistory[currentTarget]) chatHistory[currentTarget] = [];

        //             const exists = chatHistory[currentTarget].some(x => x.msg === text && x.sender === sender);
        //             if (exists) return;

        //             chatHistory[currentTarget].push({ sender, msg: text });
        //             saveHistoryToLocal();

        //             // n·∫øu ƒëang m·ªü ƒë√∫ng k√™nh
                    
        //             if (currentTarget === (currentType === "channel" ? m.channel : sender)) {
        //                 // const targetKey = ch || sender;
        //                 // showToast(`üì© ${targetKey}: ${text}`);
        //                 appendMessageToUI(sender, text, 'received');
        //             } else {
        //                 // tƒÉng s·ªë l∆∞·ª£ng tin ch∆∞a ƒë·ªçc
        //                 const targetKey = ch || sender;
        //                 showToast(`üì© ${targetKey}: ${text}`);
        //                 unreadCounts[currentTarget] = (unreadCounts[currentTarget] || 0) + 1;
        //                 fetchData();
        //             }
        //         });

        //     } catch (e) {
        //         console.error("fetchMessages error:", e);
        //     }
        // }

        //b·∫£n g·∫ßn ƒë√∫ng 1
        async function fetchMessages() {
            if (!currentUser) return;

            let url = "/get-messages";

            if (currentType === "channel") {
                url += `?channel=${currentTarget}`;
            } else {
                url += `?peer_id=${currentUser}`;
            }

            try {
                const response = await fetch(url);
                if (!response.ok) return;

                const data = await response.json();
                const msgs = data.messages || data;

                msgs.forEach(m => {
                    const sender = m.sender;
                    const text   = m.msg || m.message;
                    const ch     = m.channel || null;  // n·∫øu l√† tin nh·∫Øn channel

                    // x√°c ƒë·ªãnh key ƒë·ªÉ l∆∞u history
                    const key = currentType === "channel" ? currentTarget : sender;

                    if (!chatHistory[key]) chatHistory[key] = [];

                    // tr√°nh tr√πng tin
                    const exists = chatHistory[key].some(x => x.msg === text && x.sender === sender);
                    if (exists) return;

                    chatHistory[key].push({ sender, msg: text });
                    saveHistoryToLocal();

                    // ===== TR∆Ø·ªúNG H·ª¢P USER ƒêANG XEM CHANNEL / PRIVATE =====
                    if (currentType === "channel" && ch === currentTarget) {
                        appendMessageToUI(sender, text, 'received');
                        return;
                    }

                    if (currentType === "peer" && sender === currentTarget) {
                        appendMessageToUI(sender, text, 'received');
                        return;
                    }

                    // ===== TR∆Ø·ªúNG H·ª¢P KH√îNG ƒêANG XEM ‚Üí TƒÇNG UNREAD + SHOW TOAST =====
                    const targetKey = ch || sender; // channel th√¨ key = channelName, private th√¨ = sender

                    unreadCounts[targetKey] = (unreadCounts[targetKey] || 0) + 1;

                    showToast(`üì© ${targetKey}: ${text}`);

                    // c·∫≠p nh·∫≠t UI danh s√°ch
                    fetchData();
                });

            } catch (e) {
                console.error("fetchMessages error:", e);
            }
        }

        // async function fetchMessages() {
        //     if (!currentUser) return;

        //     let url = "/get-messages";

        //     if (currentType === "channel") {
        //         url += `?channel=${currentTarget}`;
        //     } else {
        //         url += `?peer_id=${currentUser}`;
        //     }

        //     try {
        //         const response = await fetch(url);
        //         if (!response.ok) return;

        //         const data = await response.json();
        //         const msgs = data.messages || data;

        //         msgs.forEach(m => {
        //             const sender = m.sender;
        //             const text   = m.msg || m.message;
        //             const ch     = m.channel || null;

        //             // =====================
        //             // 1) X√ÅC ƒê·ªäNH KEY ƒê√öNG
        //             // =====================
        //             const key = ch ? ch : sender;

        //             if (!chatHistory[key]) chatHistory[key] = [];

        //             // =====================
        //             // 2) CH·ªêNG TR√ôNG TN
        //             // =====================
        //             const exists = chatHistory[key].some(
        //                 x => x.msg === text && x.sender === sender
        //             );
        //             if (exists) return;

        //             chatHistory[key].push({ sender, msg: text });
        //             saveHistoryToLocal();

        //             // =====================
        //             // 3) ƒêANG M·ªû ƒê√öNG CHAT?
        //             // =====================
        //             const isViewingChannel = currentType === "channel" && ch === currentTarget;
        //             const isViewingPeer    = currentType === "peer"    && sender === currentTarget;

        //             if (isViewingChannel || isViewingPeer) {
        //                 appendMessageToUI(sender, text, 'received');
        //                 return;
        //             }

        //             // =====================
        //             // 4) KH√îNG ƒêANG M·ªû ‚Üí UNREAD
        //             // =====================
        //             unreadCounts[key] = (unreadCounts[key] || 0) + 1;

        //             showToast(`üì© ${key}: ${text}`);

        //             fetchData();
        //         });

        //     } catch (e) {
        //         console.error("fetchMessages error:", e);
        //     }
        // }




        // --- HELPER UI & STORAGE ---
        function loadChatHistory(target) {
            const msgWindow = document.getElementById('message-window');
            msgWindow.innerHTML = `<div class="system-msg">${currentType === 'channel' ? 'üì¢' : 'üë§'} ${target}</div>`;
            const list = chatHistory[target] || [];
            list.forEach(item => {
                const type = item.sender === currentUser ? 'sent' : 'received';
                appendMessageToUI(item.sender, item.msg, type);
            });
        }

        function appendMessageToUI(sender, text, type) {
            const msgWindow = document.getElementById('message-window');
            const div = document.createElement('div');
            div.className = `message ${type}`;
            
            let html = `<div class="msg-content">${text}</div>`;
            // N·∫øu l√† tin nh·∫≠n ƒë∆∞·ª£c v√† l√† chat ri√™ng, hi·ªán t√™n ng∆∞·ªùi g·ª≠i
            // N·∫øu chat k√™nh, sender ch√≠nh l√† t√™n k√™nh -> trong content text ƒë√£ c√≥ "Hung: hello"
            if (type === 'received' && currentType === 'direct') {
                html = `<div class="msg-sender">${sender}</div>` + html;
            }
            div.innerHTML = html;
            msgWindow.appendChild(div);
            msgWindow.scrollTop = msgWindow.scrollHeight;
        }

        function saveHistoryToLocal() {
            if (currentUser) localStorage.setItem(`hist_${currentUser}`, JSON.stringify(chatHistory));
        }
        function loadHistoryFromLocal() {
            if (currentUser) {
                const s = localStorage.getItem(`hist_${currentUser}`);
                if (s) chatHistory = JSON.parse(s);
            }
        }
        function showToast(msg) {
            const d = document.createElement("div");
            d.innerText = msg;
            d.style.cssText = "position:fixed;top:20px;right:20px;background:#333;color:#fff;padding:10px;border-radius:5px;z-index:999";
            document.body.appendChild(d);
            setTimeout(() => document.body.removeChild(d), 3000);
        }
        const user = localStorage.getItem('peer_name');
        if (!user) {
            window.location.href = "/login.html";
        } else {
            document.getElementById('current-user-display').innerText = `T√¥i: ${user}`;
            startChatApp(user);
        }

        function handleEnter(e) {
            if (e.key === 'Enter') sendMessage();
        }
    </script>
</body>
</html>